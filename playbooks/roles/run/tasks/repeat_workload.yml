---
- name: ({{ notes }}) ensure the presence of remote output dirs
  become: yes
  file:
    owner: "{{ ansible_user }}"
    path: "{{ remote_output_dir }}"
    state: directory
  loop: "{{ device_names }}"
  loop_control:
    loop_var: device_name

- name: ({{ notes }}) ensure the presence of local output dirs
  become: yes
  local_action:
    module: file
    owner: "{{ lookup('env', 'USER') }}"
    path: "{{ local_output_dir }}"
    state: directory
  loop: "{{ device_names }}"
  loop_control:
    loop_var: device_name

- name: ({{ notes }}) request identification info of drives
  become: yes
  shell: >
    hdparm -I {{ device_fullname }} > {{ remote_hdparm_id_info_file }}
  vars:
    device_name: "{{ device_fullname | basename }}"
  loop: "{{ device_fullnames }}"
  loop_control:
    loop_var: device_fullname

- include_tasks: backup_file.yml
  vars:
    local_file: "{{ local_hdparm_id_info_file }}"
    remote_file: "{{ remote_hdparm_id_info_file }}"
  loop: "{{ device_names }}"
  loop_control:
    loop_var: device_name

- block:
    - name: ({{ notes }}) check the validity of the RocksDB data dirs
      stat:
        follow: yes
        path: "{{ rocksdb_data_dir }}/CURRENT"
      loop: "{{ device_names }}"
      loop_control:
        loop_var: device_name
      register: stat_res

    - debug:
        msg: >
          RocksDB data dir {{ item.invocation.module_args.path | dirname }} does not contain valid data!
          You may need to load the data first.
      when: item.stat.isreg is not defined or not item.stat.isreg
      failed_when: item.stat.isreg is not defined or not item.stat.isreg
      loop: "{{ stat_res.results }}"
  when: not load_data

- block:
    - name: ({{ notes }}) deploy the workload independent pre-conditioning job file
      template:
        backup: no
        dest: "{{ remote_wipc_job_file }}"
        force: yes
        owner: "{{ ansible_user }}"
        src: "{{ wipc_job_filename }}"
      vars:
        device_name: "{{ device_fullname | basename }}"
      loop: "{{ device_fullnames }}"
      loop_control:
        loop_var: device_fullname

    - include_tasks: backup_file.yml
      vars:
        local_file: "{{ local_wipc_job_file }}"
        remote_file: "{{ remote_wipc_job_file }}"
      loop: "{{ device_names }}"
      loop_control:
        loop_var: device_name

    - name: ({{ notes }}) deploy the RocksDB options file
      template:
        backup: yes
        dest: "{{ rocksdb_remote_input_options_file }}"
        force: yes
        owner: "{{ ansible_user }}"
        src: "{{ rocksdb_options_file }}"
      loop: "{{ device_names }}"
      loop_control:
        loop_var: device_name
  when: load_data

- name: ({{ notes }}) copy user-defined workload parameter file to {{ local_tmp_data_dir }}
  local_action:
    module: copy
    backup: yes
    dest: "{{ local_tmp_data_dir }}/{{ cur_workload }}"
    force: yes
    owner: "{{ lookup('env', 'USER') }}"
    remote_src: no
    src: "{{ cur_workload_path }}"
  when: cur_workload_path not in core_workloads

- name: ({{ notes }}) deploy workload parameter file
  template:
    backup: yes
    dest: "{{ remote_workload_file }}"
    force: yes
    owner: "{{ ansible_user }}"
    src: "{{ local_tmp_data_dir }}/{{ cur_workload }}"
  loop: "{{ device_names }}"
  loop_control:
    loop_var: device_name
  register: template_res

- name: ({{ notes }}) append common properties to parameter file
  blockinfile:
    backup: no
    block: "{{ lookup('template', 'common') }}"
    create: no
    insertafter: EOF
    owner: "{{ ansible_user }}"
    path: "{{ remote_workload_file }}"
    state: present
  loop: "{{ device_names }}"
  loop_control:
    loop_var: device_name

- name: ({{ notes }}) clean backup
  shell: |
    if cmp -s {{ item.backup_file }} {{ item.dest }}; then
      rm --force {{ item.backup_file }}
    fi
  when: item.backup_file is defined
  loop: "{{ template_res.results }}"

- include_tasks: backup_file.yml
  vars:
    local_file: "{{ local_workload_file }}"
    remote_file: "{{ remote_workload_file }}"
  loop: "{{ device_names }}"
  loop_control:
    loop_var: device_name

- include_tasks: kill_procs.yml
  loop: "{{ device_names }}"
  loop_control:
    loop_var: device_name

- include_tasks: start_collect_perfs.yml
  loop: "{{ device_fullnames }}"
  loop_control:
    loop_var: device_fullname

- set_fact:
    cur_load_data: "{{ load_data }}"
    cur_trace_transactions_block_rq: "{{ trace_transactions_block_rq }}"
    outer_notes_repeat: "{{ notes }}"
    tracking_values: {}
    steady_state: False

- include_tasks: do_run.yml
  vars:
    notes: "{{ outer_notes_repeat }}, round {{ cur_round }}"

    # flag 'b' for before the workload execution
    # flag 'a' for after the workload execution
    device_stats_filename: "device_stats_round{{ cur_round }}_{{ flag }}.log"

    local_device_stats_file: "{{ local_output_dir }}/{{ device_stats_filename }}"
    remote_device_stats_file: "{{ remote_output_dir }}/{{ device_stats_filename }}"
    device_stats_command: >
      grep '{{ device_name }}' /proc/diskstats
  loop: "{{ range(1, maximum_rounds + 1) | list }}"
  loop_control:
    loop_var: cur_round

- include_tasks: stop_collect_perfs.yml
  loop: "{{ device_names }}"
  loop_control:
    loop_var: device_name

- include_tasks: backup_perf_logs.yml
  loop: "{{ device_names }}"
  loop_control:
    loop_var: device_name
...
