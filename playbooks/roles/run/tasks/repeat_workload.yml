---
- name: ({{ notes }}) ensure the presence of remote output dir {{ remote_output_dir }}
  become: yes
  file:
    owner: "{{ ansible_user }}"
    path: "{{ remote_output_dir }}"
    state: directory

- name: ({{ notes }}) ensure the presence of local output dir {{ local_output_dir }}
  become: yes
  local_action:
    module: file
    owner: "{{ lookup('env', 'USER') }}"
    path: "{{ local_output_dir }}"
    state: directory

- block:
    - name: ({{ notes }}) check the validity of the RocksDB data dir {{ rocksdb_data_dir }}
      stat:
        follow: yes
        path: "{{ rocksdb_data_dir }}/CURRENT"
      register: stat_res

    - debug:
        msg: >
          RocksDB data dir {{ rocksdb_data_dir }} does not contain valid data!
      when: stat_res.stat.isreg is not defined or not stat_res.stat.isreg
      failed_when: stat_res.stat.isreg is not defined or not stat_res.stat.isreg
  when: not load_data

- name: ({{ notes }}) ensure the presence of RocksDB data dir {{ rocksdb_data_dir }}
  become: yes
  file:
    owner: "{{ ansible_user }}"
    path: "{{ rocksdb_data_dir }}"
    state: "{{ item }}"
  loop:
    - absent
    - directory
  when: load_data

- name: ({{ notes }}) copy user-defined workload parameter file to {{ local_tmp_data_dir }}
  local_action:
    module: copy
    backup: yes
    dest: "{{ local_tmp_data_dir }}/{{ cur_workload }}"
    force: yes
    owner: "{{ lookup('env', 'USER') }}"
    remote_src: no
    src: "{{ cur_workload_path }}"
  when: cur_workload_path not in core_workloads

- name: ({{ notes }}) deploy workload parameter file
  template:
    backup: yes
    dest: "{{ remote_workload_file }}"
    force: yes
    owner: "{{ ansible_user }}"
    src: "{{ local_tmp_data_dir }}/{{ cur_workload }}"
  register: template_res

- name: ({{ notes }}) append common properties to parameter file
  blockinfile:
    backup: no
    block: "{{ lookup('template', 'common') }}"
    create: no
    insertafter: EOF
    owner: "{{ ansible_user }}"
    path: "{{ remote_workload_file }}"
    state: present

- name: ({{ notes }}) clean backup
  shell: |
    if cmp -s {{ template_res.backup_file }} {{ remote_workload_file }}; then
      rm -f {{ template_res.backup_file }}
    fi
  when: template_res.backup_file is defined

- include_tasks: backup_file.yml
  vars:
    local_file: "{{ local_workload_file }}"
    remote_file: "{{ remote_workload_file }}"

- name: ({{ notes }}) kill the remnant processes for collecting system performance statistics
  become: yes
  shell: pkill -SIGTERM --pidfile {{ item }} ; rm --force {{ item }}
  loop:
    - "{{ cpustat_pid_file }}"
    - "{{ memstat_pid_file }}"
    - "{{ blkstat_pid_file }}"

- name: ({{ notes }}) start to collect system performance statistics
  # we use stdbuf to turn off the buffering of the output redirection.
  #   https://linux.die.net/man/1/stdbuf
  #   https://stackoverflow.com/a/1429973
  shell: >
    nohup stdbuf -oL -eL {{ item.command }} < /dev/null > {{ item.remote_log_file }} 2>&1 &
    echo $! > {{ item.pid_file }}
  environment:
    S_TIME_FORMAT: ISO
  loop:
    - { command: mpstat -P ALL 3,
        remote_log_file: "{{ remote_cpustat_log_file }}",
        pid_file: "{{ cpustat_pid_file }}" }
    # We need to especially check the values of si and so. If these are non-zero, youâ€™re out of memory.
    - { command: vmstat --one-header --wide --unit K --timestamp 3,
        remote_log_file: "{{ remote_memstat_log_file }}",
        pid_file: "{{ memstat_pid_file }}" }

- name: ({{ notes }}) get the parent device ID of device {{ device_name }}
  command: "{{ role_path }}/files/majmin2dev.sh {{ device_name }}"
  register: comm_res
  changed_when: False

- name: ({{ notes }}) start to trace the block events for device {{ comm_res.stdout_lines[0] }}
  become: yes
  # A very good article: "trace-cmd: A front-end for Ftrace"
  #   https://lwn.net/Articles/410200/
  # Some definitions of the block I/O events:
  #   https://www.ibm.com/developerworks/community/blogs/58e72888-6340-46ac-b488-d31aa4058e9c/entry/exploring_the_linux_storage_path_tracing_block_i_o_kernel_events?lang=en_us
  shell: >
    trace-cmd reset && trace-cmd record
      -o {{ remote_blkstat_log_file }}
      --date
      -e block:block_rq_issue
      -f "dev == {{ comm_res.stdout_lines[1] }}"
      -e block:block_rq_complete
      -f "dev == {{ comm_res.stdout_lines[1] }}" &
    echo $! > {{ blkstat_pid_file }}

- block:
    - name: ({{ notes }}) deploy the RocksDB options file
      template:
        backup: yes
        dest: "{{ remote_rocksdb_options_file }}"
        force: yes
        owner: "{{ ansible_user }}"
        src: "{{ rocksdb_options_file }}"

    - include_tasks: backup_file.yml
      vars:
        local_file: "{{ local_rocksdb_options_file }}"
        remote_file: "{{ remote_rocksdb_options_file }}"

    - name: ({{ notes }}) load the data
      shell: >
        bin/ycsb load rocksdb -s
        -P {{ remote_workload_file }}
        -p rocksdb.dir={{ rocksdb_data_dir }}
        -p options.file={{ remote_rocksdb_options_file }}
        > {{ remote_output_file }} 2>&1
      args:
        chdir: "{{ ycsb_dir }}"
      environment:
        PATH: "{{ maven_dir }}/bin:{{ ansible_env.PATH }}"

    - include_tasks: backup_file.yml
      vars:
        local_file: "{{ local_output_file }}"
        remote_file: "{{ remote_output_file }}"
  when: load_data

- set_fact:
    outer_notes_repeat: "{{ notes }}"
    tracking_values: []
    steady_state: False

- include_tasks: do_run.yml
  vars:
    notes: "{{ outer_notes_repeat }}, round {{ cur_round }}"
    output_filename: "transactions_round{{ cur_round }}.dat"

    # flag 'b' for before the workload execution
    # flag 'a' for after the workload execution
    device_stats_filename: "device_stats_round{{ cur_round }}_{{ flag }}.log"

    local_device_stats_file: "{{ local_output_dir }}/{{ device_stats_filename }}"
    remote_device_stats_file: "{{ remote_output_dir }}/{{ device_stats_filename }}"
    device_stats_command: >
      grep -w '{{ device_name | basename }}' /proc/diskstats
  loop: "{{ range(1, maximum_rounds + 1) | list }}"
  loop_control:
    loop_var: cur_round

- name: ({{ notes }}) stop to collect system performance statistics
  become: yes
  shell: pkill -SIGINT --pidfile {{ item }} ; rm --force {{ item }}
  loop:
    - "{{ cpustat_pid_file }}"
    - "{{ memstat_pid_file }}"
    - "{{ blkstat_pid_file }}"

- name: ({{ notes }}) pause to wait all the performance statistics collecting processes finished
  pause:
    seconds: 10

- include_tasks: backup_file.yml
  vars:
    local_file: "{{ item.local_file }}"
    remote_file: "{{ item.remote_file }}"
  loop:
    - { local_file: "{{ local_cpustat_log_file }}",
        remote_file: "{{ remote_cpustat_log_file }}" }
    - { local_file: "{{ local_memstat_log_file }}",
        remote_file: "{{ remote_memstat_log_file }}" }
    - { local_file: "{{ local_blkstat_log_file }}",
        remote_file: "{{ remote_blkstat_log_file }}" }
...
