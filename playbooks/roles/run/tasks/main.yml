---
- name: stop RocksDB RMI servers
  command: pkill -SIGTERM --full {{ rocksdbjni_rmi_jar_name }}
  register: comm_res
  changed_when: comm_res.rc == 0
  ignore_errors: yes

- name: wait for related ports to be released
  pause:
    minutes: 2
  when: hostvars[item]['comm_res']['rc'] == 0
  loop: "{{ groups['all'] }}"

- name: acquire processes running on the rmi ports
  become: yes
  command: lsof -i :{{ item }}
  loop: "{{ rmi_ports }}"
  changed_when: False
  ignore_errors: yes
  register: comm_res

- name: check whether the rmi ports are free
  debug:
    msg: >
      Port {{ item.item }} is not free on host {{ inventory_hostname }}
  when: item.rc == 0
  failed_when: item.rc == 0
  loop: "{{ comm_res.results }}"

- include_tasks: create_dirs.yml

- name: fetch the core workload parameter files
  fetch:
    dest: "{{ local_tmp_data_dir }}/"
    fail_on_missing: yes
    flat: yes
    src: "{{ ycsb_dir }}/workloads/{{ item }}"
  vars:
    device_name: "{{ device_names[0] }}"
  loop: "{{ core_workloads }}"
  delegate_to: localhost
  run_once: yes

- block:
    - name: get size of devices in bytes
      become: yes
      command: blockdev --getsize64 {{ device_fullname }}
      changed_when: False
      loop: "{{ device_fullnames }}"
      loop_control:
        loop_var: device_fullname
      register: comm_res

    - name: create a dict to map from device to device_size
      set_fact:
        # see Combining hashes/dictionaries
        #   https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#combining-hashes-dictionaries
        device_sizes: "{{ device_sizes | default({}) | combine({ (item.device_fullname | basename) : item.stdout }) }}"
      loop: "{{ comm_res.results }}"
  when: load_data

- name: copy the {{ io_accounting_script_filename }} script to the remote
  copy:
    backup: no
    dest: "{{ scripts_dir }}/"
    force: yes
    mode: u+rx
    src: "{{ role_path }}/files/{{ io_accounting_script_filename }}"

- name: check remnant data files
  stat:
    get_attributes: no
    get_checksum: no
    get_mime: no
    path: "{{ local_output_inventory }}"
  delegate_to: localhost
  run_once: yes
  register: stat_res

- block:
    - name: confirm deleting remnant data files
      pause:
        prompt: >
          Remnant data files from previous run are found!
          Do you want to delete those files and continue (yes/no)?
        echo: yes
      register: confirm_res
      failed_when: confirm_res.user_input not in ["yes", "y"]

    - name: delete remnant data files (remote)
      file:
        path: "{{ remote_data_dir | basename }}"
        state: absent
      vars:
        device_name: "{{ device_names[0] }}"

    - name: delete remnant data files (local)
      file:
        path: "{{ local_output_inventory }}"
        state: absent
      delegate_to: localhost
      run_once: yes
  when: stat_res.stat.isdir is defined and stat_res.stat.isdir

- include_tasks: repeat_workload.yml
  vars:
    cur_workload: "{{ cur_workload_path | basename }}"
    notes: "{{ cur_workload }}"
  loop: "{{ run_workloads }}"
  loop_control:
    loop_var: cur_workload_path
...
