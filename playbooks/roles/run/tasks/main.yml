---
- name: stop RocksDB RMI servers
  command: pkill -SIGTERM --full {{ rocksdbjni_rmi_jar | basename }}
  register: comm_res
  changed_when: comm_res.rc == 0
  ignore_errors: yes

- name: wait for related ports to be released
  pause:
    seconds: 15
  when: comm_res.rc == 0

- name: acquire processes running on the rmi ports
  become: yes
  command: lsof -i :{{ item }}
  loop: "{{ rmi_ports }}"
  changed_when: False
  ignore_errors: yes
  register: comm_res

- name: check whether the rmi ports are free
  debug:
    msg: >
      Port {{ item.item }} is not free on host {{ inventory_hostname }}
  when: item.rc == 0
  failed_when: item.rc == 0
  loop: "{{ comm_res.results }}"

- include_tasks: create_dirs.yml

- name: fetch the core workload parameter files
  fetch:
    dest: "{{ local_tmp_data_dir }}/"
    fail_on_missing: yes
    flat: yes
    src: "{{ ycsb_dir }}/workloads/{{ item }}"
  vars:
    device_name: "{{ device_names[0] }}"
  loop: "{{ core_workloads }}"
  delegate_to: localhost
  run_once: yes

- block:
    - name: get size of devices in bytes
      become: yes
      command: blockdev --getsize64 {{ device_fullname }}
      changed_when: False
      loop: "{{ device_fullnames }}"
      loop_control:
        loop_var: device_fullname
      register: comm_res

    - name: create a dict to map from device to device_size
      set_fact:
        # see Combining hashes/dictionaries
        #   https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#combining-hashes-dictionaries
        device_sizes: "{{ device_sizes | default({}) | combine({ (item.device_fullname | basename) : item.stdout }) }}"
      loop: "{{ comm_res.results }}"

    - name: download the device purge script
      get_url:
        backup: no
        dest: "{{ remote_scripts_dir }}/{{ device_purge_script_filename }}"
        force: yes
        mode: u+rx
        owner: "{{ ansible_user }}"
        url: https://raw.githubusercontent.com/ljishen/SSSPT/master/playbooks/roles/common/files/{{ device_purge_script_filename }}
  when: load_data

- name: copy the {{ io_accounting_script_filename }} script to the remote
  copy:
    backup: no
    dest: "{{ remote_scripts_dir }}/"
    force: yes
    mode: u+rx
    src: "{{ role_path }}/files/{{ io_accounting_script_filename }}"

- include_tasks: repeat_workload.yml
  vars:
    cur_workload: "{{ cur_workload_path | basename }}"
    notes: "{{ cur_workload }}"
  loop: "{{ run_workloads }}"
  loop_control:
    loop_var: cur_workload_path
...
