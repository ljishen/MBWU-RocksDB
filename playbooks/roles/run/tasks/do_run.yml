---
- block:

    - block:
        - name: ({{ notes }}) ensure the presence of RocksDB data dir {{ rocksdb_data_dir }}
          become: yes
          file:
            owner: "{{ ansible_user }}"
            path: "{{ rocksdb_data_dir }}"
            state: "{{ item }}"
          loop:
            - absent
            - directory

        - name: ({{ notes }}) load the data
          shell: >
            bin/ycsb load rocksdb -s
            -P {{ remote_workload_file }}
            -p rocksdb.dir={{ rocksdb_data_dir }}
            -p options.file={{ remote_rocksdb_options_file }}
            > {{ remote_load_output_file }} 2>&1
          args:
            chdir: "{{ ycsb_dir }}"
          environment:
            PATH: "{{ maven_dir }}/bin:{{ ansible_env.PATH }}"

        - name: ({{ notes }}) print the size of database dir after loaded
          command: du -BK {{ rocksdb_data_dir }}

        - include_tasks: backup_file.yml
          vars:
            local_file: "{{ local_load_output_file }}"
            remote_file: "{{ remote_load_output_file }}"
      when: cur_load_data

    - set_fact:
        cur_load_data: False
      when: load_data_once

    - name: ({{ notes }}) kill the remnant processes for tracing block requests
      become: yes
      shell: pkill -SIGTERM --pidfile {{ blkstat_pid_file }} ; rm --force {{ blkstat_pid_file }}

    - name: ({{ notes }}) free the slab objects and pagecache
      # See https://www.kernel.org/doc/Documentation/sysctl/vm.txt
      become: yes
      shell: sync; echo 3 > /proc/sys/vm/drop_caches

    - block:
        - name: ({{ notes }}) get the parent device ID of device {{ device_name }}
          command: "{{ role_path }}/files/majmin2dev.sh {{ device_name }}"
          register: comm_res
          changed_when: False

        - name: ({{ notes }}) disable all kernel tracing and clear the trace buffers
          become: yes
          # The `trace-cmd record` process will not start if we combine this and
          # the `trace-cmd record` command together.
          command: trace-cmd reset

        - name: ({{ notes }}) start to trace the block events for device {{ comm_res.stdout_lines[0] }}
          become: yes
          # A very good article: "trace-cmd: A front-end for Ftrace"
          #   https://lwn.net/Articles/410200/
          # Some definitions of the block I/O events:
          #   https://www.ibm.com/developerworks/community/blogs/58e72888-6340-46ac-b488-d31aa4058e9c/entry/exploring_the_linux_storage_path_tracing_block_i_o_kernel_events?lang=en_us
          shell: >
            nohup trace-cmd record
            -o {{ remote_blkstat_log_file }}
            --date
            -e block:block_rq_issue
            -f "dev == {{ comm_res.stdout_lines[1] }}"
            -e block:block_rq_complete
            -f "dev == {{ comm_res.stdout_lines[1] }}"
            < /dev/null > {{ workdir }}/nohup.out 2>&1 &
            echo $! > {{ blkstat_pid_file }}

        - name: ({{ notes }}) pause to wait for the tracer to start
          pause:
            seconds: 7
      when: cur_trace_block_rq

    - name: ({{ notes }}) get the stats of device {{ device_name }} (before)
      # We don't want to interfere the stats of the block device so just not to
      # write the result directly to file here.
      shell: "{{ device_stats_command }}"
      register: before_stats_res

    - name: ({{ notes }}) execute the workload
      shell: >
        bin/ycsb run rocksdb -s
        -P {{ remote_workload_file }}
        -p rocksdb.dir={{ rocksdb_data_dir }}
        > {{ remote_transactions_output_file }} 2>&1
      args:
        chdir: "{{ ycsb_dir }}"
      environment:
        PATH: "{{ maven_dir }}/bin:{{ ansible_env.PATH }}"

    - name: ({{ notes }}) get the stats of device {{ device_name }} (after)
      shell: "{{ device_stats_command }}"
      register: after_stats_res

    - include_tasks: backup_file.yml
      vars:
        local_file: "{{ local_transactions_output_file }}"
        remote_file: "{{ remote_transactions_output_file }}"

    - name: ({{ notes }}) save device stats to files
      copy:
        backup: no
        content: "{{ item.register.stdout }}"
        dest: "{{ remote_device_stats_file }}"
        force: yes
        owner: "{{ ansible_user }}"
      vars:
        flag: "{{ item.flag }}"
      loop:
        - { register: "{{ before_stats_res }}", flag: 'b' }
        - { register: "{{ after_stats_res }}", flag: 'a' }

    - include_tasks: backup_file.yml
      vars:
        flag: "{{ item }}"
        local_file: "{{ local_device_stats_file }}"
        remote_file: "{{ remote_device_stats_file }}"
      loop: [ 'b', 'a' ]

    - block:
        - name: ({{ notes }}) stop to trace block requests
          become: yes
          shell: pkill -SIGINT --pidfile {{ blkstat_pid_file }} ; rm --force {{ blkstat_pid_file }}

        - name: ({{ notes }}) pause to wait for the block request tracer to finish
          pause:
            seconds: 30

        - name: ({{ notes }}) archive the blkstat log file
          archive:
            format: gz
            owner: "{{ ansible_user }}"
            path: "{{ remote_blkstat_log_file }}"
            remove: no
          register: archive_res

        - include_tasks: backup_file.yml
          vars:
            local_file: "{{ local_output_dir }}{{ archive_res.dest | basename }}"
            remote_file: "{{ archive_res.dest }}"
      when: cur_trace_block_rq

    - set_fact:
        cur_trace_block_rq: False
      when: trace_block_rq_once

    - name: ({{ notes }}) extract the throughput value from output
      command: >
        grep -oP '\[OVERALL\],\s+Throughput\(ops/sec\),\s+\K[\d.]+' {{ remote_transactions_output_file }}
      register: comm_res

    - name: ({{ notes }}) save throughput for steady state detection
      set_fact:
        tracking_values: "{{ tracking_values + [ comm_res.stdout | float ] }}"

    - name: ({{ notes }}) check steady state
      script: >
        {{ role_path }}/files/verify_ss.py '{{ tracking_values }}' {{ measurement_window_size }}
      register: script_res
      ignore_errors: yes

    - name: ({{ notes }}) update loop condition
      set_fact:
        steady_state: "{{ True if script_res.rc == 0 else False }}"

  when: not steady_state
...
